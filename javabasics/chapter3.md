## Java archives (JAR-files)

In the last chapter we mentioned zipping all generated class-files in one zip-file and handing it over to a colleague.
This is basically what is being done in the real world, with just a bit more structure to it.
Such a file is called a JAR-file (Java ARchive), and is what this chapter is focused on.

Let's start off with the setup we ended the previous chapter on.

The following directory-structure:

```
source/
  |- com/
    |- example/
      |- collamdaan/
        |- a/
          |- StringUtils.java
        |- b/
          |- StringUtils.java
target/
```

and the following source files:

`source/com/example/collamdaan/a/StringUtils.java`
```java
package com.example.collamdaan.a;

public class StringUtils
{
    public boolean isEmptyOrNull(String s)
    {
        return s == null || s.isEmpty();
    }
}
```

`source/com/example/collamdaan/b/StringUtils.java`
```java
package com.example.collamdaan.b;

public class StringUtils
{
    public boolean isUuid(String s)
    {
        return s != null && s.length() == 36 && s.matches("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
    }
}
```

Now let's compile those source files:

```sh
$ javac -d target/ source/com/example/collamdaan/a/StringUtils.java source/com/example/collamdaan/b/StringUtils.java
```

A JAR-file is essentially a zip-file containing Java class-files (and other related files) and one specific metadata file, the manifest (`MANIFEST.MF`).
This manifest is usually generated by whatever process is used to create the JAR-file and creates meta-information such as the creation time of the JAR-file, what JDK was used to create it, and such.
The manifest-file is usually not relevant to developers so we won't go into too much detail here.

Let's create a JAR-file of our target directory.

```sh
jar cf chapter3.jar -C target/ .
```

Those parameters mean:
- `c` create
- `f` file, specifies the jar file
- `-C target/ .` add all files in the target-directory, but strip `target/` of their path.

When we now inspect our JAR-file, we see the added class files, as well as an automatically created MANIFEST.MF

```sh
$ unzip -t chapter3.jar
Archive:  chapter3.jar
    testing: META-INF/                OK
    testing: META-INF/MANIFEST.MF     OK
    testing: com/                     OK
    testing: com/example/             OK
    testing: com/example/collamdaan/   OK
    testing: com/example/collamdaan/a/   OK
    testing: com/example/collamdaan/a/StringUtils.class   OK
    testing: com/example/collamdaan/b/   OK
    testing: com/example/collamdaan/b/StringUtils.class   OK
No errors detected in compressed data of chapter3.jar.
```

As you can see, it has added the directories inside the target/ directory, but not the target-directory itself, as well as creating a MANIFEST.MF file inside a META-INF directory.
This directory is a special directory that can also hold other files describing properties of the JAR-file or the combined set of classes within the JAR-file.
We'll see more examples in later chapters.

When we inspect the MANIFEST.MF, we'll see it doesn't contain a lot.

```sh
$ unzip -p chapter3.jar META-INF/MANIFEST.MF
Manifest-Version: 1.0
Created-By: 25.0.1 (Ubuntu)
```

(The exact contents will vary from system to system.)

## Self-executing JAR-files

JAR-files can be self-executing, meaning that when you execute the JAR-file, it will automatically execute the main-method of a specific class.
This doesn't require much, just a class with a main-method and an entry in the manifest specifying which class to execute.

`source/com/collamdaan/StringTester.java`
```java
package com.collamdaan;

public class StringTester
{
    public static void main(String[] args)
    {
        String a = "";
        String b = "ea55684e-6819-44c6-a1a4-df0a7a8e2001";

        System.out.println("Testing String a:'"+a+"', 
